<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PowerDynamics.jl Node · BlockSystems.jl</title><link rel="canonical" href="https://hexaeder.github.io/BlockSystems.jl/generated/pd_node/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BlockSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../spacecraft/">Spacecraft</a></li><li class="is-active"><a class="tocitem" href>PowerDynamics.jl Node</a><ul class="internal"><li><a class="tocitem" href="#Generate-PowerDynamics.jl-Node-with-BlockSystems"><span>Generate <code>PowerDynamics.jl</code>-Node with <code>BlockSystems</code></span></a></li><li><a class="tocitem" href="#Compare-against-VSIVoltagePT1"><span>Compare against <code>VSIVoltagePT1</code></span></a></li><li><a class="tocitem" href="#Benchmark"><span>Benchmark</span></a></li></ul></li><li><a class="tocitem" href="../kuramoto_without_nd/">Kuramoto without ND.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>PowerDynamics.jl Node</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PowerDynamics.jl Node</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/hexaeder/BlockSystems.jl/blob/master/examples/pd_node.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Generate-PowerDynamics.jl-Node-with-BlockSystems"><a class="docs-heading-anchor" href="#Generate-PowerDynamics.jl-Node-with-BlockSystems">Generate <code>PowerDynamics.jl</code>-Node with <code>BlockSystems</code></a><a id="Generate-PowerDynamics.jl-Node-with-BlockSystems-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-PowerDynamics.jl-Node-with-BlockSystems" title="Permalink"></a></h2><p>We want to model the <a href="https://juliaenergy.github.io/PowerDynamics.jl/dev/node_types/#PowerDynamics.VSIVoltagePT1"><code>VSIVoltagePT1</code></a> with the help of <code>BlockSystems</code>.</p><p>We start by defining some general stuff...</p><pre><code class="language-julia">using BlockSystems
using ModelingToolkit

@parameters t
D = Differential(t)</code></pre><h3 id="Defining-the-common-Blocks"><a class="docs-heading-anchor" href="#Defining-the-common-Blocks">Defining the common Blocks</a><a id="Defining-the-common-Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-common-Blocks" title="Permalink"></a></h3><p>We need some common parts such as filters or integrators. The actual Blocks will be defined by using these &#39;blueprints&#39;. Stuff like this should go to a library of components at some point.</p><h4 id="low-pass-filter"><a class="docs-heading-anchor" href="#low-pass-filter">low pass filter</a><a id="low-pass-filter-1"></a><a class="docs-heading-anchor-permalink" href="#low-pass-filter" title="Permalink"></a></h4><pre><code class="language-julia">@parameters τ input(t)
@variables filtered(t)

lpf = IOBlock([D(filtered) ~ 1/τ * (- filtered + input)],
              [input], [filtered])</code></pre><pre class="documenter-example-output">IOBlock :##IOBlock#663 with 1 eqs
  ├ inputs:  input(t)
  ├ outputs: filtered(t)
  ├ istates: (empty)
  └ iparams: τ</pre><h4 id="voltage-source"><a class="docs-heading-anchor" href="#voltage-source">voltage source</a><a id="voltage-source-1"></a><a class="docs-heading-anchor-permalink" href="#voltage-source" title="Permalink"></a></h4><pre><code class="language-julia">@parameters ω(t) v(t) τ
@variables u_i(t) u_r(t) A(t)

# explicit algebraic equation for A will be reduced at connect
voltage_source = IOBlock([A ~ 1/τ * (v/√(u_i^2 + u_r^2) - 1),
                          D(u_r) ~ -ω * u_i + A*u_r,
                          D(u_i) ~  ω * u_r + A*u_i],
                         [ω, v], [u_i, u_r])</code></pre><pre class="documenter-example-output">IOBlock :##IOBlock#664 with 3 eqs
  ├ inputs:  ω(t), v(t)
  ├ outputs: u_i(t), u_r(t)
  ├ istates: A(t)
  └ iparams: τ</pre><h4 id="Droop-control"><a class="docs-heading-anchor" href="#Droop-control">Droop control</a><a id="Droop-control-1"></a><a class="docs-heading-anchor-permalink" href="#Droop-control" title="Permalink"></a></h4><pre><code class="language-julia">@parameters K u_ref x_ref x(t)
@variables u(t)

droop_control = IOBlock([
    u ~ - K * (x - x_ref) + u_ref # output is the droop voltage v
    ], [x], [u])</code></pre><pre class="documenter-example-output">IOBlock :##IOBlock#665 with 1 eqs
  ├ inputs:  x(t)
  ├ outputs: u(t)
  ├ istates: (empty)
  └ iparams: K, u_ref, x_ref</pre><p>After defining the blueprints we can create the Blocks of the system based on them:</p><pre><code class="language-julia">p_filter = IOBlock(lpf, name = :p_filter)
q_filter = IOBlock(lpf, name = :q_filter)
p_droop = IOBlock(droop_control, name = :p_droop)
q_droop = IOBlock(droop_control, name = :q_droop)
v_source = IOBlock(voltage_source, name = :v_source)</code></pre><p>We can put the blocks together to form this system:</p><pre><code class="language-none">     +----------+  +-------------+
 P --| p_filter |--|   p_droop   |   +----------+
     |    τ     |  | u_ref, xref |---|          |
     +----------+  +-------------+  ω| v_source |-- u_r
                                     |    τ     |
     +----------+  +-------------+  v|          |-- u_i
 Q --| q_filter |--|   q_droop   |---|          |
     |    τ     |  | u_ref, xref |   +----------+
     +----------+  +-------------+
</code></pre><pre><code class="language-julia">gfi = IOSystem([p_filter.filtered =&gt; p_droop.x,
                q_filter.filtered =&gt; q_droop.x,
                p_droop.u =&gt; v_source.ω,
                q_droop.u =&gt; v_source.v],
               [p_filter, q_filter, p_droop, q_droop, v_source],
               name = :GridForming,
               namespace_map = [p_filter.input =&gt; :P_in,
                                q_filter.input =&gt; :Q_in,
                                p_filter.filtered =&gt; :p_filtered,
                                q_filter.filtered =&gt; :q_filtered,
                                # parameter names which match VSIVoltagePT1
                                v_source.τ =&gt; :τ_v, # time constant voltage control delay
                                p_filter.τ =&gt; :τ_P, # time constant active power measurement
                                q_filter.τ =&gt; :τ_Q, # time constant reactive power measurement
                                p_droop.K  =&gt; :K_P, # droop constant frequency droop
                                q_droop.K  =&gt; :K_Q, # droop constant voltage droop
                                q_droop.u_ref =&gt; :V_r, # reference/ desired voltage
                                p_droop.u_ref =&gt; :ω_r, # reference/ desired frequency
                                p_droop.x_ref =&gt; :P, # active (real) power infeed
                                q_droop.x_ref =&gt; :Q], # reactive (imag) power infeed                .
               outputs = [v_source.u_i, v_source.u_r])</code></pre><pre class="documenter-example-output">IOSystem :GridForming with 5 subsystems
  ├ p_filter: input(t) ↦ filtered(t)
  ├ q_filter: input(t) ↦ filtered(t)
  ├ p_droop: x(t) ↦ u(t)
  ├ q_droop: x(t) ↦ u(t)
  └ v_source: ω(t), v(t) ↦ u_i(t), u_r(t)
and 4 connections:
  ├ p_filter₊filtered(t) ⇒ p_droop₊x(t)
  ├ q_filter₊filtered(t) ⇒ q_droop₊x(t)
  ├ p_droop₊u(t) ⇒ v_source₊ω(t)
  └ q_droop₊u(t) ⇒ v_source₊v(t)
inputs:
  ├ p_filter₊input(t) ⇒ P_in(t)
  └ q_filter₊input(t) ⇒ Q_in(t)
outputs:
  ├ v_source₊u_i(t) ⇒ u_i(t)
  └ v_source₊u_r(t) ⇒ u_r(t)
istates:
  ├ p_droop₊u(t), q_droop₊u(t) (unpromoted)
  ├ v_source₊A(t) ⇒ A(t)
  ├ p_filter₊filtered(t) ⇒ p_filtered(t)
  └ q_filter₊filtered(t) ⇒ q_filtered(t)
iparams:
  ├ p_filter₊τ ⇒ τ_P
  ├ q_filter₊τ ⇒ τ_Q
  ├ p_droop₊K ⇒ K_P
  ├ p_droop₊u_ref ⇒ ω_r
  ├ p_droop₊x_ref ⇒ P
  ├ q_droop₊K ⇒ K_Q
  ├ q_droop₊u_ref ⇒ V_r
  ├ q_droop₊x_ref ⇒ Q
  └ v_source₊τ ⇒ τ_v</pre><p>There is still one problem: our connected system has the inputs <code>P</code> and <code>Q</code>. In order to construct IONodes the IOSystems have to be systems which convert some complex current to complex voltage:</p><pre><code class="language-none">       +---------+
i_r --&gt;|   ???   |--&gt; u_r
i_i --&gt;|         |--&gt; u_i
       +---------+</code></pre><p>We can achieve this by defining a nother block which converts <code>(i, u) ↦ (P, Q)</code></p><pre><code class="language-none">               +----------+  +-------------+
     +-----+   | p_filter |--|   p_droop   |   +----------+
i_r--|     |-P-|   p_τ    |  |   P, ω_r    |---|          |
i_i--| pow |   +----------+  +-------------+  ω| v_source |---+--u_r
     |     |                                   |    τ     |   |
 +---|     |   +----------+  +-------------+  v|          |-+-|--u_i
 | +-|     |-Q-| q_filter |--|   q_droop   |---|          | | |
 | | +-----+   |   q_τ    |  |   Q, v_r    |   +----------+ | |
 | |           +----------+  +-------------+                | |
 | +--------------------------------------------------------+ |
 +-----------------------------------------------------------+
</code></pre><pre><code class="language-julia">@parameters u_i(t) u_r(t) i_i(t) i_r(t)
@variables P_in(t) Q_in(t)
pow = IOBlock([P_in ~ u_r*i_r + u_i*i_i,
               Q_in ~ u_i*i_r - u_r*i_i],
              [u_i, u_r, i_i, i_r], [P_in, Q_in], name=:pow)

gfi2 = IOSystem([gfi.u_i =&gt; pow.u_i,
                 gfi.u_r =&gt; pow.u_r,
                 pow.P_in =&gt; gfi.P_in,
                 pow.Q_in =&gt; gfi.Q_in],
                [gfi, pow], outputs=[gfi.u_i, gfi.u_r], name=:gfi_i_to_u)</code></pre><p>and the system can be reduced to a single IOBlock</p><pre><code class="language-julia">connected = connect_system(gfi2)</code></pre><p>The following part should live inside <code>PowerDynamics.jl</code> at some point. It defines an <code>IONode</code> which will be constructed from an <code>IOBlock</code> as a new <code>AbstractNode</code> type.</p><pre><code class="language-julia">using PowerDynamics
using NetworkDynamics: ODEVertex
struct IONode{T} &lt;: AbstractNode
    block::IOBlock
    generated::T
    parameters::Vector{Float64}
end

function IONode(blk::IOBlock, parameters::Dict)
    # BlockSpec: blk must by of type (i_r, i_i) ↦ (u_r, u_i)
    spec = BlockSpec([:i_r, :i_i], [:u_r, :u_i])
    @assert spec(blk) &quot;Block has to follow PowerDynamics i/o conventions!&quot;
    # TODO check parameters
    gen = generate_io_function(blk,
                               f_states=[blk.u_r, blk.u_i],
                               f_inputs=[blk.i_r, blk.i_i],
                               f_params=keys(parameters), warn=false);
    IONode(blk, gen, collect(values(parameters)))
end

import PowerDynamics.construct_vertex
function construct_vertex(ion::IONode)
    gen = ion.generated
    function rhs!(dx, x, e_s, e_d, _p, t)
        i = total_current(e_s, e_d)
        gen.f_ip(dx, x, (real(i), imag(i)), ion.parameters, t)
    end
    ODEVertex(f! = rhs!, dim = length(gen.states), mass_matrix = gen.massm, sym = Symbol.(gen.states))
end

import PowerDynamics.symbolsof
PowerDynamics.symbolsof(ionode::IONode) = Symbol.(ionode.generated.states)
PowerDynamics.dimension(ionode::IONode) = length(ionode.generated.states)</code></pre><pre class="documenter-example-output">┌ Warning: This implementation of a line fault will be deprecated soon. Please use LineFailure instead.
└ @ PowerDynamics ~/.julia/packages/PowerDynamics/dEcT3/src/faults/LineFailure.jl:22</pre><p>Let&#39;s try it out: The parameters have to be provided as a Dict. This dict should contain all internal parameters of the block. The list of parameters can be retrieved from the block:</p><pre><code class="language-julia">@info &quot;connected system:&quot; connected.iparams</code></pre><pre class="documenter-example-output">┌ Info: connected system:
│   connected.iparams =
│    9-element Array{SymbolicUtils.Symbolic,1}:
│     τ_P
│     τ_Q
│     K_P
│     P
│     ⋮
│     τ_v
│     K_Q
└     ω_r</pre><p>The parameter dict can be defined in several ways, I think the first option is the most convenient because it is a pure <code>Symbol</code> which does not depend on any variables in the scope. The namespace separator can be typed as <code>\_+&lt;tab&gt;</code>.</p><pre><code class="language-none">:τ_P =&gt; 1.0
:gfi_i_to_u₊τ_P =&gt; 1.0
connected.τ_P =&gt; 1.0</code></pre><pre><code class="language-julia">para = Dict(
    :τ_v =&gt; 0.005,    # time constant voltage control delay
    :τ_P =&gt; 0.5,      # time constant active power measurement
    :τ_Q =&gt; 0.5,      # time constant reactive power measurement
    :K_P =&gt; 0.396,     # droop constant frequency droop
    :K_Q =&gt; 0.198,     # droop constant voltage droop
    :V_r =&gt; 1.0,   # reference/ desired voltage
    :P   =&gt; 0.303, # active (real) power infeed
    :Q   =&gt; 0.126, # reactive (imag) power infeed                .
    :ω_r =&gt; 0.0)   # refrence/ desired frequency</code></pre><p>Now let&#39;s test whether this works in PD...</p><pre><code class="language-">using PowerDynamics: SlackAlgebraic, PiModelLine,PowerGrid,find_operationpoint
using OrderedCollections: OrderedDict

buses=OrderedDict(
    &quot;bus1&quot;=&gt; IONode(connected, para),
    &quot;bus2&quot;=&gt; SlackAlgebraic(U=1))

branches=OrderedDict(
    &quot;branch1&quot;=&gt; PiModelLine(from= &quot;bus1&quot;, to = &quot;bus2&quot;,y=4.999131600798035-1im*15.263086523179553, y_shunt_km=0.0528/2, y_shunt_mk=0.0528/2))

powergrid = PowerGrid(buses,branches)
operationpoint = find_operationpoint(powergrid)
timespan= (0.0,0.1)
nothing #hide</code></pre><p>simulating a voltage perturbation at node 1</p><pre><code class="language-">fault1 = ChangeInitialConditions(node=&quot;bus1&quot;, var=:u_r, f=Inc(0.2))
solution1 = simulate(fault1, powergrid, operationpoint, timespan)
using Plots
plot(solution1.dqsol)</code></pre><h2 id="Compare-against-VSIVoltagePT1"><a class="docs-heading-anchor" href="#Compare-against-VSIVoltagePT1">Compare against <code>VSIVoltagePT1</code></a><a id="Compare-against-VSIVoltagePT1-1"></a><a class="docs-heading-anchor-permalink" href="#Compare-against-VSIVoltagePT1" title="Permalink"></a></h2><p>We  want to compare the newly defined node against the <code>VSIVoltagePT1</code> node for random data. Both nodes have slightly different states:</p><ul><li><code>symbolsof(node_bs) == [:u_r, :u_i, :p_filtered, :q_filtered]</code></li><li><code>symbolsof(node_pd) == [:u_r, :u_i, :ω, :q_m]</code></li></ul><p>We need adapt the initial state for the different third variable:</p><p class="math-container">\[\omega = \omega_r - K_P\cdot(p_{\mathrm{filtered}} - P)\\
\dot\omega = - K_P \cdot \dot{p}_{\mathrm{filtered}}\]</p><pre><code class="language-">using Test
@testset &quot;Compare IONode vs. PD Node&quot; begin
    for i in 1:100
        para = Dict(
            :τ_v =&gt; rand(), # time constant voltage control delay
            :τ_P =&gt; rand(), # time constant active power measurement
            :τ_Q =&gt; rand(), # time constant reactive power measurement
            :K_P =&gt; rand(), # droop constant frequency droop
            :K_Q =&gt; rand(), # droop constant voltage droop
            :V_r =&gt; rand(), # reference/ desired voltage
            :P   =&gt; rand(), # active (real) power infeed
            :Q   =&gt; rand(), # reactive (imag) power infeed                .
            :ω_r =&gt; 0.0)    # refrence/ desired frequency

        # create IONode
        node_bs = IONode(connected, para)
        f_bs = construct_vertex(node_bs).f!

        # create PDNode
        # the PD node does not have the explicit ω_r parameter
        para_pd = delete!(copy(para), :ω_r)
        nt = NamedTuple{Tuple(keys(para_pd))}(values(para_pd))
        node_pd = VSIVoltagePT1(; nt...)
        f_pd = construct_vertex(node_pd).f!

        # create fake &quot;edge data&quot;, 4 incoming, 4 outgooing with 4 states each
        es = [randn(4) for i in 1:4]
        ed = [randn(4) for i in 1:4]

        # select random time
        t = rand()

        # chose random initial state and account for initial ω in PD node
        x_bs = randn(4)
        x_pd = copy(x_bs)
        x_pd[3] = - para[:K_P] * (x_bs[3] - para[:P])

        # create arrays for the results
        dx_bs = similar(x_bs)
        dx_pd = similar(x_pd)

        # call both functions
        f_bs(dx_bs, x_bs, es, ed, nothing, t)
        f_pd(dx_pd, x_pd, es, ed, nothing, t)

        # compare results
        # we have to correct variable 3 of bs implementation to match dω
        @test dx_bs[1] ≈ dx_pd[1]                # u_r
        @test dx_bs[2] ≈ dx_pd[2]                # u_i
        @test - para[:K_P] * dx_bs[3] ≈ dx_pd[3] # ω
        @test dx_bs[4] ≈ dx_pd[4]                # q_filtered
    end
end
nothing #hide</code></pre><p>it works 🎉</p><h2 id="Benchmark"><a class="docs-heading-anchor" href="#Benchmark">Benchmark</a><a id="Benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark" title="Permalink"></a></h2><p>We can also run a quick benchmark of both node functions:</p><pre><code class="language-">para = Dict(:τ_v=&gt;rand(),:τ_P=&gt;rand(), :τ_Q=&gt;rand(),
            :K_P=&gt;rand(), :K_Q=&gt;rand(), :V_r=&gt;rand(),
            :P=&gt;rand(), :Q=&gt;rand(), :ω_r=&gt;0.0)

node_bs = IONode(connected, para)
f_bs = construct_vertex(node_bs).f!
para_pd = delete!(copy(para), :ω_r)
nt = NamedTuple{Tuple(keys(para_pd))}(values(para_pd))
node_pd = VSIVoltagePT1(; nt...)
f_pd = construct_vertex(node_pd).f!

es = [randn(4) for i in 1:4]
ed = [randn(4) for i in 1:4]
t = rand()

# chose random initial state and account for initial ω in PD node
x_bs = randn(4)
x_pd = copy(x_bs)
x_pd[3] = - para[:K_P] * (x_bs[3] - para[:P])
dx = similar(x_bs)

using BenchmarkTools
@btime $f_bs($dx, $x_bs, $es, $ed, nothing, $t)
@btime $f_pd($dx, $x_pd, $es, $ed, nothing, $t)</code></pre><p>it seems like the <code>IONode</code> is even a bit faster.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../spacecraft/">« Spacecraft</a><a class="docs-footer-nextpage" href="../kuramoto_without_nd/">Kuramoto without ND.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 4 June 2021 17:53">Friday 4 June 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
