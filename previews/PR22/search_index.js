var documenterSearchIndex = {"docs":
[{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"EditURL = \"https://github.com/hexaeder/BlockSystems.jl/blob/master/examples/kuramoto_without_nd.jl\"","category":"page"},{"location":"generated/kuramoto_without_nd/#Network-Dynamics-without-NetworkDynamics.jl","page":"Kuramoto without ND.jl","title":"Network Dynamics without NetworkDynamics.jl","text":"","category":"section"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"In this example we model a Kuramoto system on a complex network.","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"using Pkg\nPkg.activate(@__DIR__)\n\nusing LightGraphs\nusing BlockSystems\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing Plots","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"Dynamical systems on complex networks are best modelled on directed graphs, because in general an interaction of node i and j may be asymmetric, e.g. when node i influences node j but not vice versa.","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"Symmetries of the system such as (anti-)symmetric coupling functions may justify other approaches, but those are of limited scope, for a detailed discussion see https://arxiv.org/abs/2012.12696, Section II.D.","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"In the following each edge is represented by a function:","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"     e₁₂ = f(1,2)\n     .--->---.\n   (1)       (2)\n     ˙---<---˙\n     e₂₁ = f(2,1)","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"Each edge funciton sees the values of the connected nodes, its source and its destination. Node are modeled as functions as well and see all their incoming edges.","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"The goal is to generate IOBlocks for edges and vertices based on a given graph.","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"While defining the edge block is straightforward, we have to make the vertex blocks a bit special: since MTK does not support vector inputs yet we need a special IOBlock which depends on the number of connected edges.","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"function gen_edge_block(name)\n    @parameters t src(t) dst(t) K\n    @variables out(t)\n    IOBlock([out ~ K*sin(src-dst)], [src, dst], [out], name=Symbol(name))\nend\n\nfunction gen_vertex_block(n_edges, name)\n    @parameters t ω\n    @parameters edge[1:n_edges](t)\n    @variables ϕ(t)\n    D = Differential(t)\n\n    IOBlock([D(ϕ) ~ ω + (+)(edge...)],\n            [edge...],\n            [ϕ],\n            name=Symbol(name))\nend\nnothing #hide","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"For simplicity our graph will be a simple ring network specified with LightGraphs.jl","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"N = 8\ng = SimpleDiGraph(watts_strogatz(N,2,0)) # ring network\nnothing #hide","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"First we generate a list of all edge-blocks because they don't depend on the vertices.","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"edgelist = [(i=i, src=e.src, dst=e.dst, block=gen_edge_block(\"e_$(e.src)_$(e.dst)\"))\n            for (i, e) in enumerate(edges(g))]\nedge_blocks = [e.block for e in edgelist]\nnothing #hide","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"Now we can generate vertex blocks based on their number of incoming edges. We will also create the connections","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"edge_i_to_k.out => node.edge₁\nedge_j_to_k.out => node.edge₂\n...","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"for all edges that go from vertices i or j to vertex k.","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"vert_blocks = IOBlock[]\nconnections = Pair[]\n\nfor i in vertices(g)\n    # collect the incoming edges for each node\n    edges = filter(e -> e.dst == i, edgelist)\n\n    node = gen_vertex_block(length(edges), \"v$i\")\n    push!(vert_blocks, node)\n\n    # each node has the open inputs edge₁, edge₂, ...\n    # we need to connect the ouputs of the edge-blocks to the\n    # inputs of the node like edge_j_to_1.out => node.edge₁\n    for (i, edge) in enumerate(edges)\n        node_input_i = getproperty(node, Symbol(\"edge\", Char(0x02080 + i)))\n        push!(connections, edge.block.out => node_input_i)\n    end\nend","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"Once the vertices are generated we can plug the edges' src and dst to the output of the # corresponding vertex, in this case its the oscillators angle ϕ","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"for edge in edgelist\n    push!(connections, vert_blocks[edge.src].ϕ => edge.block.src)\n    push!(connections, vert_blocks[edge.dst].ϕ => edge.block.dst)\nend","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"We want the connect_system to get rid of the algebraic states for the edges. Therefore we have to provide a list of outputs which only contains the outputs of the vertices. By doing so the edge outputs will become internal istates of the IOSystem and upon connection may be reduced.","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"outputs = [block.ϕ for block in vert_blocks]\n\nnetwork = IOSystem(connections, vcat(vert_blocks, edge_blocks), outputs=outputs)\n\nnetworkblock = connect_system(network, verbose=false)\nnothing #hide","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"As the output shows the system has be reduced to just N equations. Well now we can generate the functions...","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"gen = generate_io_function(networkblock,\n                           f_states=[v.ϕ for v in vert_blocks],\n                           f_params=vcat([v.ω for v in vert_blocks],\n                                         [e.K for e in edge_blocks]),\n                           warn=false);\nnothing #hide","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"... enclose the f_ip to get rid of the empty inputs field...","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"odefun(du, u, p, t) = gen.f_ip(du, u, (), p, t)\nnothing #hide","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"... set the starting conditions ...","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"ω = collect(1:N)./N\nω .-= sum(ω)/N\nK = [3.0 for i in edge_blocks]\np = (ω..., K...)\n\nx0 = collect(1:N)./N\nx0 .-= sum(x0)./N\nnothing #hide","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"... and solve the system!","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"tspan = (0., 10.)\nprob = ODEProblem(odefun, x0, tspan, p)\nsol = solve(prob, Tsit5())\nplot(sol, ylabel=\"ϕ\")","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"","category":"page"},{"location":"generated/kuramoto_without_nd/","page":"Kuramoto without ND.jl","title":"Kuramoto without ND.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"EditURL = \"https://github.com/hexaeder/BlockSystems.jl/blob/master/examples/spacecraft.jl\"","category":"page"},{"location":"generated/spacecraft/#Control-System:-Spaceship","page":"Spacecraft","title":"Control System: Spaceship","text":"","category":"section"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"As an example we want to build an IOSystem controlling the altitude of a spacecraft. The spacecraft has mass m and can be controlled with thrusters which apply the force F(t) to the spacecraft. The altitude x(t)","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"dot v(t) = frac F(t) m\ndot x(t) =  v(t)","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"in our model this system has the input F(t), the internal state v(t) (vertical velocity) and the output x(t).","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"       +------------+\nF(t) --| spacecraft |-- x(t)\n       | m, v(t)    |\n       +------------+\n","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"using BlockSystems\nusing ModelingToolkit\n@parameters t M F(t)\n@variables x(t) v(t)\nD = Differential(t)\n\nspacecraft = IOBlock([D(v) ~ F/M, D(x) ~ v], # define the equation\n                     [F], # inputs of the system\n                     [x], # outputs of the system\n                     name = :spacecraft)","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"We want to model a controller which takes a desired altitude as an input parameter and outputs the force for thrusters.","category":"page"},{"location":"generated/spacecraft/#Simple-proportional-controller","page":"Spacecraft","title":"Simple proportional controller","text":"","category":"section"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"A proportional controller takes an input i and calculates the output proportional to the input.","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":" o(t) = Kcdot i(t)","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"       +--------+\ni(t) --| prop K |-- o(t)\n       +--------+","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"@parameters K i(t)\n@variables o(t)\n\nprop = IOBlock([o ~ K*i], [i], [o], name = :prop)\nnothing # hide","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"In order to make this useful as an controller, the input has to be the difference between the reference and the system variable (negative feedback). We can model this as an IOSystem where","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"Δ = p - m","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"       +--------+\np(t) --|  diff  |-- Δ(t)\nm(t) --|        |\n       +--------+","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"@parameters p(t) m(t)\n@variables Δ(t)\ndiff = IOBlock([Δ ~ p - m], [p, m], [Δ], name=:diff)\nnothing # hide","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"Now we can connect both of the defined models to create an proportional controller","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"             +----------------------------------------+\n             | propc                                  |\n             |         +--------+   +--------+        |\n  target(t)--|--p(t) --|  diff  |---| prop K |--o(t)--|--o(t)\nfeedback(t)--|--m(t) --|        |   +--------+        |\n             |         +--------+                     |\n             +----------------------------------------+","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"If we don't provide additional information the system will try to promote all of the enclosed variables to the new systemwide namespace.","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"prop_c = IOSystem([diff.Δ => prop.i], # connect output of diff to input of prop\n                  [diff, prop], # subsystems\n                  name=:propc)","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"For finer control, it is often preferred to give new names manually, this is done with the namespace_map argument. Per default, all of the outputs of the subsystems will become outputs of the connected system (in this case also the output diff.Δ). We can prevent this by supplying the outputs argument manually. Sub outputs which are not referenced here will become internal states of the connected system.","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"The rhs of the namespace map can be given as a Variable/Parameter type from MTK. For simple renaming one can also give the rhs as a Symbol type.","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"prop_c = IOSystem([diff.Δ => prop.i], [diff, prop],\n                  namespace_map = [prop.o => o,\n                                   diff.p => :target,\n                                   diff.m => :feedback],\n                  outputs = [o],\n                  name=:propc)","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"Right now, the created object is a container for the two included systems. However, it is possible to transform the object into a new IOBlock by calling the connect_system function. The resulting is equivalent to","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"             +----------------------------------+\n  target(t)--| prop_c_block                     |--o(t)\nfeedback(t)--| o(t)=K*(target(t) - feedback(t)) |\n             +----------------------------------+","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"prop_c_block = connect_system(prop_c)\nnothing #hide","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"Now we can hook our spaceship to this controller. It does not matter whether we use the connected IOBlock version prop_c or the IOSystem version prop_c_block. We want to build the connected system","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"           +--------------------------------------------+\n           |  control system                            |\n           |       +--------+   +------------+          |\ntarget(t)--|-------| prop_c |---| spacecraft |-x(t)--+--|--altitude(t)\n           |  +-fb-|        |   | m, v(t)    |       |  |\n           |  |    +--------+   +------------+       |  |\n           |  +--------------------------------------+  |\n           +--------------------------------------------+","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"@variables altitude(t)\nspace_controller = IOSystem([prop_c.o => spacecraft.F, spacecraft.x => prop_c.feedback],\n                            [prop_c, spacecraft],\n                            namespace_map = [spacecraft.x => altitude],\n                            outputs = [altitude])\n# we want to reduce the space_controller to a block\nspace_controller = connect_system(space_controller)\n@info \"Variables of space_controller\" space_controller space_controller.system.eqs","category":"page"},{"location":"generated/spacecraft/#Simulate-System","page":"Spacecraft","title":"Simulate System","text":"","category":"section"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"In order to simulate the system we can have to build the Julia functions.","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"gen = generate_io_function(space_controller)\nnothing # hide","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"By doing so we get access to a named tuple with the fileds","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"gen.f_ip in-place function\ngen.f_oop out-of-place function\ngen.massm mass matrix of the system\ngen.states symbols of states (in order)\ngen.inputs symbols of inputs (in order)\ngen.params symbols of parameters (in order)\n(see docstring for full list)","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"The functions have the form f_ip(du, u, inputs, params, t) where u are all the states (outputs stacked on top of internal states) and t is the independent variable of the system. The order of the inputs and states can be controlled.","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"gen = generate_io_function(space_controller, f_states=[altitude, v], f_params=[K, M])\n@info \"Generated function\" gen.massm gen.states gen.inputs gen.params\nnothing # hide","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"Well, let's see how our model is doing.","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"using Plots\nusing OrdinaryDiffEq\ntargetfun(t) = t>1.0 ? 1.0 : 0\nodefun(du, u, p, t) = gen.f_ip(du, u, [targetfun(t)], p, t)\np = [0.5, 1.0] # K, m\nu0 = [0.0, 0.0] # altitude, v\ntspan = (0.0, 30.0)\nprob = ODEProblem(odefun, u0, tspan, p)\nsol = solve(prob, Tsit5())\nplot(t->sol(t)[1],tspan..., label=\"altitude\", title=\"proportional control\")\nplot!(t->targetfun(t),tspan..., label=\"target\")","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"Well who could have thought, proportional control looks like an harmonic oscillator 🤷‍♂️","category":"page"},{"location":"generated/spacecraft/#Defining-a-better-controller","page":"Spacecraft","title":"Defining a better controller","text":"","category":"section"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"We might just add a damping term (a force proportional to the velocity of the spaceship). If it works for a harmonic oscillator, it should work for our spaceship.","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"           +--------------------------------------------------------+\n           |  control system                                        |\n           |  +--------------------------------------------------+  |\n           |  |    +--------+     +---+                          |  |\n           |  +-v--| prop_v |-(-)-| d |     +------------+       |  |\n           |       +--------+     | i |--F--| spacecraft |-v(t)--+  |\n           |       +--------+     | f |     | m          |-x(t)--+--|--altitude(t)\ntarget(t)--|-------| prop_c |-(+)-| f |     +------------+       |  |\n           |  +-fb-|        |     +---+                          |  |\n           |  |    +--------+                                    |  |\n           |  +--------------------------------------------------+  |\n           +--------------------------------------------------------+","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"In order to do so we have to slightly redefine the spaceship system: now the velocity v(t) is also an output and not and internal state.","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"spacecraft = IOBlock([D(v) ~ F/M, D(x) ~ v],\n                     [F],\n                     [x,v],\n                     name = :spacecraft)","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"One can define new blocks based on previously defined blocks.","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"prop_v = IOBlock(prop, name=:prop_v)\nfdiff = IOBlock(diff, name=:fdiff)\n\nspace_controller = IOSystem([spacecraft.v => prop_v.i,\n                             spacecraft.x => prop_c.feedback,\n                             prop_c.o => fdiff.p,\n                             prop_v.o => fdiff.m,\n                             fdiff.Δ => spacecraft.F],\n                            [prop_v, prop_c, fdiff, spacecraft],\n                            namespace_map = [spacecraft.x => altitude],\n                            outputs = [altitude])\n\nspace_controller = connect_system(space_controller)\ngen = generate_io_function(space_controller, f_states=[altitude, v], f_params=[prop_c.K, M, prop_v.K])\n\nodefun(du, u, p, t) = gen.f_ip(du, u, [targetfun(t)], p, t)\np = [1.0, 1.0, 0.5] # propc, M, propv\nu0 = [0.0, 0.0] # altitude, v\ntspan = (0.0, 30.0)\nprob = ODEProblem(odefun, u0, tspan, p)\nsol = solve(prob, Tsit5())\nplot(sol, vars=(0,1), label=\"altitude\", title=\"better control\")\nplot!(t->targetfun(t),tspan..., label=\"target\")","category":"page"},{"location":"generated/spacecraft/#Defining-an-PT1-controller","page":"Spacecraft","title":"Defining an PT1 controller","text":"","category":"section"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"             +-----------------------------------------------+\n             | pi_c                                   +---+  |\n             |                           +------------|   |  |\n             |        +----+  +--------+ | +-------+  |sum|--|--o(t)\n  target(t)--|--p(t)--|diff|--| prop K |-+-| int T |--|   |  |\nfeedback(t)--|--m(t)--|    |  +--------+   +-------+  +---+  |\n             |        +----+                                 |\n             +-----------------------------------------------+","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"@parameters T a1(t) a2(t)\n@variables Σ(t) altitude(t)\nint = IOBlock([D(o) ~ 1/T * i - o], [i], [o], name=:int)\nadder = IOBlock([Σ ~ a1 + a2], [a1, a2], [Σ], name=:add)\n\npi_c = IOSystem([diff.Δ => prop.i,\n                 prop.o => int.i,\n                 prop.o => adder.a1,\n                 int.o => adder.a2],\n                [diff, prop, int, adder],\n                namespace_map = [diff.p => :target,\n                                 diff.m => :feedback,\n                                 adder.Σ => o],\n                outputs = [o],\n                name=:pi_c)\nnothing # hide","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"as before we can close the loop and build the control circuit","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"space_controller = IOSystem([pi_c.o => spacecraft.F , spacecraft.x => pi_c.feedback],\n                            [pi_c, spacecraft],\n                            namespace_map = [spacecraft.x => altitude],\n                            outputs = [altitude])\nspace_controller = connect_system(space_controller, verbose=false)\n@info \"Variables of space_controller\" space_controller space_controller.system.eqs","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"and we can simulate and plot the system","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"gen = generate_io_function(space_controller, f_states=[altitude], f_params=[K, T, M])\n\nodefun(du, u, p, t) = gen.f_ip(du, u, [targetfun(t)], p, t)\np = [0.5, -1.5, 1.0] # K, T, m\nu0 = [0.0, 0.0, 0.0] # altitude, int.o, v\ntspan = (0.0, 50.0)\nprob = ODEProblem(odefun, u0, tspan, p)\nsol = solve(prob, Tsit5())\nplot(sol, vars=(0,[ 1,2 ]), label=[\"altitude\" \"integrator\"], title=\"PT1 controller\")\nplot!(t->targetfun(t),tspan..., label=\"target\")","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"thank you for flying with us :)","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"","category":"page"},{"location":"generated/spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"EditURL = \"https://github.com/hexaeder/BlockSystems.jl/blob/master/examples/pd_node.jl\"","category":"page"},{"location":"generated/pd_node/#Generate-PowerDynamics.jl-Node-with-BlockSystems","page":"PowerDynamics.jl Node","title":"Generate PowerDynamics.jl-Node with BlockSystems","text":"","category":"section"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"We want to model the VSIVoltagePT1 with the help of BlockSystems.","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"We start by defining some general stuff...","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"using BlockSystems\nusing ModelingToolkit\n\n@parameters t\nD = Differential(t)\nnothing #hide","category":"page"},{"location":"generated/pd_node/#Defining-the-common-Blocks","page":"PowerDynamics.jl Node","title":"Defining the common Blocks","text":"","category":"section"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"We need some common parts such as filters or integrators. The actual Blocks will be defined by using these 'blueprints'. Stuff like this should go to a library of components at some point.","category":"page"},{"location":"generated/pd_node/#low-pass-filter","page":"PowerDynamics.jl Node","title":"low pass filter","text":"","category":"section"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"@parameters τ input(t)\n@variables filtered(t)\n\nlpf = IOBlock([D(filtered) ~ 1/τ * (- filtered + input)],\n              [input], [filtered])","category":"page"},{"location":"generated/pd_node/#voltage-source","page":"PowerDynamics.jl Node","title":"voltage source","text":"","category":"section"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"@parameters ω(t) v(t) τ\n@variables u_i(t) u_r(t) A(t)\n\n# explicit algebraic equation for A will be reduced at connect\nvoltage_source = IOBlock([A ~ 1/τ * (v/√(u_i^2 + u_r^2) - 1),\n                          D(u_r) ~ -ω * u_i + A*u_r,\n                          D(u_i) ~  ω * u_r + A*u_i],\n                         [ω, v], [u_i, u_r])","category":"page"},{"location":"generated/pd_node/#Droop-control","page":"PowerDynamics.jl Node","title":"Droop control","text":"","category":"section"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"@parameters K u_ref x_ref x(t)\n@variables u(t)\n\ndroop_control = IOBlock([\n    u ~ - K * (x - x_ref) + u_ref # output is the droop voltage v\n    ], [x], [u])","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"After defining the blueprints we can create the Blocks of the system based on them:","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"p_filter = IOBlock(lpf, name = :p_filter)\nq_filter = IOBlock(lpf, name = :q_filter)\np_droop = IOBlock(droop_control, name = :p_droop)\nq_droop = IOBlock(droop_control, name = :q_droop)\nv_source = IOBlock(voltage_source, name = :v_source)\n\nnothing #hide","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"We can put the blocks together to form this system:","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"     +----------+  +-------------+\n P --| p_filter |--|   p_droop   |   +----------+\n     |    τ     |  | u_ref, xref |---|          |\n     +----------+  +-------------+  ω| v_source |-- u_r\n                                     |    τ     |\n     +----------+  +-------------+  v|          |-- u_i\n Q --| q_filter |--|   q_droop   |---|          |\n     |    τ     |  | u_ref, xref |   +----------+\n     +----------+  +-------------+\n","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"gfi = IOSystem([p_filter.filtered => p_droop.x,\n                q_filter.filtered => q_droop.x,\n                p_droop.u => v_source.ω,\n                q_droop.u => v_source.v],\n               [p_filter, q_filter, p_droop, q_droop, v_source],\n               name = :GridForming,\n               namespace_map = [p_filter.input => :P_in,\n                                q_filter.input => :Q_in,\n                                p_filter.filtered => :p_filtered,\n                                q_filter.filtered => :q_filtered,\n                                # parameter names which match VSIVoltagePT1\n                                v_source.τ => :τ_v, # time constant voltage control delay\n                                p_filter.τ => :τ_P, # time constant active power measurement\n                                q_filter.τ => :τ_Q, # time constant reactive power measurement\n                                p_droop.K  => :K_P, # droop constant frequency droop\n                                q_droop.K  => :K_Q, # droop constant voltage droop\n                                q_droop.u_ref => :V_r, # reference/ desired voltage\n                                p_droop.u_ref => :ω_r, # reference/ desired frequency\n                                p_droop.x_ref => :P, # active (real) power infeed\n                                q_droop.x_ref => :Q], # reactive (imag) power infeed                .\n               outputs = [v_source.u_i, v_source.u_r])","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"There is still one problem: our connected system has the inputs P and Q. In order to construct IONodes the IOSystems have to be systems which convert some complex current to complex voltage:","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"       +---------+\ni_r -->|   ???   |--> u_r\ni_i -->|         |--> u_i\n       +---------+","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"We can achieve this by defining a nother block which converts (i, u) ↦ (P, Q)","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"               +----------+  +-------------+\n     +-----+   | p_filter |--|   p_droop   |   +----------+\ni_r--|     |-P-|   p_τ    |  |   P, ω_r    |---|          |\ni_i--| pow |   +----------+  +-------------+  ω| v_source |---+--u_r\n     |     |                                   |    τ     |   |\n +---|     |   +----------+  +-------------+  v|          |-+-|--u_i\n | +-|     |-Q-| q_filter |--|   q_droop   |---|          | | |\n | | +-----+   |   q_τ    |  |   Q, v_r    |   +----------+ | |\n | |           +----------+  +-------------+                | |\n | +--------------------------------------------------------+ |\n +-----------------------------------------------------------+\n","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"@parameters u_i(t) u_r(t) i_i(t) i_r(t)\n@variables P_in(t) Q_in(t)\npow = IOBlock([P_in ~ u_r*i_r + u_i*i_i,\n               Q_in ~ u_i*i_r - u_r*i_i],\n              [u_i, u_r, i_i, i_r], [P_in, Q_in], name=:pow)\n\ngfi2 = IOSystem([gfi.u_i => pow.u_i,\n                 gfi.u_r => pow.u_r,\n                 pow.P_in => gfi.P_in,\n                 pow.Q_in => gfi.Q_in],\n                [gfi, pow], outputs=[gfi.u_i, gfi.u_r], name=:gfi_i_to_u)\nnothing #hide","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"and the system can be reduced to a single IOBlock","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"connected = connect_system(gfi2)\nnothing #hide","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"The following part should live inside PowerDynamics.jl at some point. It defines an IONode which will be constructed from an IOBlock as a new AbstractNode type.","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"using PowerDynamics\nusing NetworkDynamics: ODEVertex\nstruct IONode{T} <: AbstractNode\n    block::IOBlock\n    generated::T\n    parameters::Vector{Float64}\nend\n\nfunction IONode(blk::IOBlock, parameters::Dict)\n    # BlockSpec: blk must by of type (i_r, i_i) ↦ (u_r, u_i)\n    spec = BlockSpec([:i_r, :i_i], [:u_r, :u_i])\n    @assert spec(blk) \"Block has to follow PowerDynamics i/o conventions!\"\n    # TODO check parameters\n    gen = generate_io_function(blk,\n                               f_states=[blk.u_r, blk.u_i],\n                               f_inputs=[blk.i_r, blk.i_i],\n                               f_params=keys(parameters), warn=false);\n    IONode(blk, gen, collect(values(parameters)))\nend\n\nimport PowerDynamics.construct_vertex\nfunction construct_vertex(ion::IONode)\n    gen = ion.generated\n    function rhs!(dx, x, e_s, e_d, _p, t)\n        i = total_current(e_s, e_d)\n        gen.f_ip(dx, x, (real(i), imag(i)), ion.parameters, t)\n    end\n    ODEVertex(f! = rhs!, dim = length(gen.states), mass_matrix = gen.massm, sym = Symbol.(gen.states))\nend\n\nimport PowerDynamics.symbolsof\nPowerDynamics.symbolsof(ionode::IONode) = Symbol.(ionode.generated.states)\nPowerDynamics.dimension(ionode::IONode) = length(ionode.generated.states)","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"Let's try it out: The parameters have to be provided as a Dict. This dict should contain all internal parameters of the block. The list of parameters can be retrieved from the block:","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"@info \"connected system:\" connected.iparams","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"The parameter dict can be defined in several ways, I think the first option is the most convenient because it is a pure Symbol which does not depend on any variables in the scope. The namespace separator can be typed as \\_+<tab>.","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":":τ_P => 1.0\n:gfi_i_to_u₊τ_P => 1.0\nconnected.τ_P => 1.0","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"para = Dict(\n    :τ_v => 0.005,    # time constant voltage control delay\n    :τ_P => 0.5,      # time constant active power measurement\n    :τ_Q => 0.5,      # time constant reactive power measurement\n    :K_P => 0.396,     # droop constant frequency droop\n    :K_Q => 0.198,     # droop constant voltage droop\n    :V_r => 1.0,   # reference/ desired voltage\n    :P   => 0.303, # active (real) power infeed\n    :Q   => 0.126, # reactive (imag) power infeed                .\n    :ω_r => 0.0)   # refrence/ desired frequency\nnothing #hide","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"Now let's test whether this works in PD...","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"using PowerDynamics: SlackAlgebraic, PiModelLine,PowerGrid,find_operationpoint\nusing OrderedCollections: OrderedDict\n\nbuses=OrderedDict(\n    \"bus1\"=> IONode(connected, para),\n    \"bus2\"=> SlackAlgebraic(U=1))\n\nbranches=OrderedDict(\n    \"branch1\"=> PiModelLine(from= \"bus1\", to = \"bus2\",y=4.999131600798035-1im*15.263086523179553, y_shunt_km=0.0528/2, y_shunt_mk=0.0528/2))\n\npowergrid = PowerGrid(buses,branches)\noperationpoint = find_operationpoint(powergrid)\ntimespan= (0.0,0.1)\nnothing #hide","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"simulating a voltage perturbation at node 1","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"fault1 = ChangeInitialConditions(node=\"bus1\", var=:u_r, f=Inc(0.2))\nsolution1 = simulate(fault1, powergrid, operationpoint, timespan)\nusing Plots\nplot(solution1.dqsol)","category":"page"},{"location":"generated/pd_node/#Compare-against-VSIVoltagePT1","page":"PowerDynamics.jl Node","title":"Compare against VSIVoltagePT1","text":"","category":"section"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"We  want to compare the newly defined node against the VSIVoltagePT1 node for random data. Both nodes have slightly different states:","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"symbolsof(node_bs) == [:u_r, :u_i, :p_filtered, :q_filtered]\nsymbolsof(node_pd) == [:u_r, :u_i, :ω, :q_m]","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"We need adapt the initial state for the different third variable:","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"omega = omega_r - K_Pcdot(p_mathrmfiltered - P)\ndotomega = - K_P cdot dotp_mathrmfiltered","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"using Test\n@testset \"Compare IONode vs. PD Node\" begin\n    for i in 1:100\n        para = Dict(\n            :τ_v => rand(), # time constant voltage control delay\n            :τ_P => rand(), # time constant active power measurement\n            :τ_Q => rand(), # time constant reactive power measurement\n            :K_P => rand(), # droop constant frequency droop\n            :K_Q => rand(), # droop constant voltage droop\n            :V_r => rand(), # reference/ desired voltage\n            :P   => rand(), # active (real) power infeed\n            :Q   => rand(), # reactive (imag) power infeed                .\n            :ω_r => 0.0)    # refrence/ desired frequency\n\n        # create IONode\n        node_bs = IONode(connected, para)\n        f_bs = construct_vertex(node_bs).f!\n\n        # create PDNode\n        # the PD node does not have the explicit ω_r parameter\n        para_pd = delete!(copy(para), :ω_r)\n        nt = NamedTuple{Tuple(keys(para_pd))}(values(para_pd))\n        node_pd = VSIVoltagePT1(; nt...)\n        f_pd = construct_vertex(node_pd).f!\n\n        # create fake \"edge data\", 4 incoming, 4 outgooing with 4 states each\n        es = [randn(4) for i in 1:4]\n        ed = [randn(4) for i in 1:4]\n\n        # select random time\n        t = rand()\n\n        # chose random initial state and account for initial ω in PD node\n        x_bs = randn(4)\n        x_pd = copy(x_bs)\n        x_pd[3] = - para[:K_P] * (x_bs[3] - para[:P])\n\n        # create arrays for the results\n        dx_bs = similar(x_bs)\n        dx_pd = similar(x_pd)\n\n        # call both functions\n        f_bs(dx_bs, x_bs, es, ed, nothing, t)\n        f_pd(dx_pd, x_pd, es, ed, nothing, t)\n\n        # compare results\n        # we have to correct variable 3 of bs implementation to match dω\n        @test dx_bs[1] ≈ dx_pd[1]                # u_r\n        @test dx_bs[2] ≈ dx_pd[2]                # u_i\n        @test - para[:K_P] * dx_bs[3] ≈ dx_pd[3] # ω\n        @test dx_bs[4] ≈ dx_pd[4]                # q_filtered\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"it works 🎉","category":"page"},{"location":"generated/pd_node/#Benchmark","page":"PowerDynamics.jl Node","title":"Benchmark","text":"","category":"section"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"We can also run a quick benchmark of both node functions:","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"para = Dict(:τ_v=>rand(),:τ_P=>rand(), :τ_Q=>rand(),\n            :K_P=>rand(), :K_Q=>rand(), :V_r=>rand(),\n            :P=>rand(), :Q=>rand(), :ω_r=>0.0)\n\nnode_bs = IONode(connected, para)\nf_bs = construct_vertex(node_bs).f!\npara_pd = delete!(copy(para), :ω_r)\nnt = NamedTuple{Tuple(keys(para_pd))}(values(para_pd))\nnode_pd = VSIVoltagePT1(; nt...)\nf_pd = construct_vertex(node_pd).f!\n\nes = [randn(4) for i in 1:4]\ned = [randn(4) for i in 1:4]\nt = rand()\n\n# chose random initial state and account for initial ω in PD node\nx_bs = randn(4)\nx_pd = copy(x_bs)\nx_pd[3] = - para[:K_P] * (x_bs[3] - para[:P])\ndx = similar(x_bs)\n\nusing BenchmarkTools\n@btime $f_bs($dx, $x_bs, $es, $ed, nothing, $t)\n@btime $f_pd($dx, $x_pd, $es, $ed, nothing, $t)","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"it seems like the IONode is even a bit faster.","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"","category":"page"},{"location":"generated/pd_node/","page":"PowerDynamics.jl Node","title":"PowerDynamics.jl Node","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BlockSystems","category":"page"},{"location":"#BlockSystems","page":"Home","title":"BlockSystems","text":"","category":"section"},{"location":"#Basics","page":"Home","title":"Basics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An input-output-system is characterized by a set of equations. These equations can be either first order ODEs or explicit algebraic equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\ndot mathbf x(t) = f(mathbf x(t) mathbf y(t) mathbf i(t) p)\nmathbf y(t) = g(mathbf x(t) mathbf y(t) mathbf i(t) p)\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"such system contains of ","category":"page"},{"location":"","page":"Home","title":"Home","text":"states (x and y) and\nparameters (i, p).","category":"page"},{"location":"","page":"Home","title":"Home","text":"States are determined by the given equations (i.e. the equations describe how the states change). Parameters are externally given. For IO systems we define subgroups","category":"page"},{"location":"","page":"Home","title":"Home","text":"states\ninternal states (istates) which are meant for internal use\noutput states (outputs) which might be used as inputs for other systems\nparameters\ninternal parameters (iparams) which are typically constant and\ninputs (inputs) which can be connected to the outputs of other systems.","category":"page"},{"location":"#Types","page":"Home","title":"Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The base type for the BlockSystems is AbstractIOSystem with the has two concrete implementations. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"AbstractIOSystem","category":"page"},{"location":"#BlockSystems.AbstractIOSystem","page":"Home","title":"BlockSystems.AbstractIOSystem","text":"abstract supertype for IOBlock and IOSystem.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"An IOBlock consists of a set of equations, a set of inputs and outputs and a name.","category":"page"},{"location":"","page":"Home","title":"Home","text":"IOBlock\nIOBlock(eqs::Vector{<:Equation}, inputs, outputs; name = gensym(:IOBlock))","category":"page"},{"location":"#BlockSystems.IOBlock","page":"Home","title":"BlockSystems.IOBlock","text":"struct IOBlock <: AbstractIOSystem\n\nA basic IOSystem which consists of a single ODESystem.\n\nname::Symbol\ninputs::Array{SymbolicUtils.Symbolic,1}\niparams::Array{SymbolicUtils.Symbolic,1}\nistates::Array{SymbolicUtils.Symbolic,1}\noutputs::Array{SymbolicUtils.Symbolic,1}\nsystem::ODESystem\nremoved_states::Array{SymbolicUtils.Symbolic,1}\nremoved_eqs::Array{Equation,1}\n\n\n\n\n\n","category":"type"},{"location":"#BlockSystems.IOBlock-Tuple{Array{var\"#s25\",1} where var\"#s25\"<:Equation,Any,Any}","page":"Home","title":"BlockSystems.IOBlock","text":"IOBlock(eqs, inputs, outputs; name)\n\n\nConstruct a new IOBlock for the given arguments.\n\nusing BlockSystems, ModelingToolkit\n@parameters t i(t)\n@variables x(t) o(t)\nD = Differential(t)\n\niob = IOBlock([D(x) ~ i, o ~ x], [i], [o], name=:iob)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"An IOSystem consists of multiple AbstractIOSystems and the connections between them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"IOSystem\nIOSystem(cons, io_systems::Vector{<:AbstractIOSystem}; inputs_map = nothing, iparams_map = nothing, istates_map = nothing, outputs_map = nothing, name = gensym(:IOSystem), autopromote = true)","category":"page"},{"location":"#BlockSystems.IOSystem","page":"Home","title":"BlockSystems.IOSystem","text":"struct IOSystem <: AbstractIOSystem\n\nA composite IOSystem which consists of multiple AbstractIOSystem which are connected via a vector of namespaced pairs (subsys1.out => subsys2.in).\n\nAn IOSystem contains maps how to promote the namespaced variables of the subsystem to the new scope    subsys1₊x(t) => x(t)    subsys1₊y(t) => subsys1₊y(t)    subsys2₊y(t) => subsys2₊y(t)\n\nname::Symbol\ninputs::Array{SymbolicUtils.Symbolic,1}\niparams::Array{SymbolicUtils.Symbolic,1}\nistates::Array{SymbolicUtils.Symbolic,1}\noutputs::Array{SymbolicUtils.Symbolic,1}\nremoved_states::Array{SymbolicUtils.Symbolic,1}\nconnections::Array{Pair{SymbolicUtils.Symbolic,SymbolicUtils.Symbolic},1}\nnamespace_map::Dict{SymbolicUtils.Symbolic,SymbolicUtils.Symbolic}\nsystems::Array{AbstractIOSystem,1}\n\n\n\n\n\n","category":"type"},{"location":"#BlockSystems.IOSystem-Tuple{Any,Array{var\"#s25\",1} where var\"#s25\"<:AbstractIOSystem}","page":"Home","title":"BlockSystems.IOSystem","text":"IOSystem(cons, io_systems; namespace_map, outputs, name, autopromote)\n\n\nConstruct a new IOSystem from various subsystems. Parameters\n\ncons: the connections in the form sub1.output => sub2.input\nio_systems: Vector of subsystems\nnamespace_map: Provide collection of custom namespace promotions / renamings i.e. sub1.input => voltage. Variables without entry in the map will be promoted automatically. Automatic promotion means that the sub-namespace is removed whenever it is possible without naming conflicts. The map may contain inputs, outputs, istates, iparams and removed_states. The rhs of the map can be provided as as Symbol:sub1.input => :newname`.\noutputs: Per default, all of the subsystem outputs will become system outputs. However, by providing a list of variables as outputs only these will become outputs of the new system. All other sub-outputs will become internal states of the connected system (and might be optimized away in connect_system).\nname: namespace\nautopromote=true: enable/disable automatic promotion of variable names to system namespace\n\n\n\n\n\n","category":"method"},{"location":"#Transformations","page":"Home","title":"Transformations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each IOSystem can be transformed into an IOBlock. At this step the actual manipulation of the equations happen.","category":"page"},{"location":"","page":"Home","title":"Home","text":"connect_system","category":"page"},{"location":"#BlockSystems.connect_system","page":"Home","title":"BlockSystems.connect_system","text":"connect_system(ios; verbose, simplify_eqs)\n\n\nRecursively transform IOSystems to IOBlocks.\n\nsubstitute inputs with connected outputs\ntry to eliminate equations for internal states which are not used to calculate the specified outputs of the system.\ntry to eliminate explicit algebraic equations (i.e. outputs of internal blocks) by substituting each occurrence with their rhs. Explicit algebraic states which are marked as system outputs won't be removed.\n\nParameters:\n\nios: system to connect\nverbose=false: toggle verbosity (show equations at different steps)\nsimplify_eqs=true: toggle simplification of all equations at the end\n\n\n\n\n\n","category":"function"},{"location":"#Function-building","page":"Home","title":"Function building","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"generate_io_function","category":"page"},{"location":"#BlockSystems.generate_io_function","page":"Home","title":"BlockSystems.generate_io_function","text":"generate_io_function(ios; f_states, f_inputs, f_params, f_rem_states, expression, verbose, type, warn)\n\n\nGenerate callable functions for an AbstractIOSystem. An IOSystem will be transformed to an IOBlock first. At this level there is no more distinction between internal states and outputs: states=(istates ∪ outputs).\n\nParameters:\n\nios: the system to build the function\n\noptional:\n\ntype=:auto: :ode or :static, determines the output of the function\nf_states: define states=(istates ∪ outputs) which should appear first\nf_inputs: define inputs which should appear first\nf_params: define parameters which should appear first\nf_rem_states: define removed states algebraic state order\nexpression=Val{false}: toggle expression and callable function output\nwarn=true: toggle warnings for missing f_* parameters\n\nReturns an named tuple with the fields\n\nfor type=:ode:\nf_ip in-place function f(dstates, states, inputs, params, iv)\nf_oop out-of-place function f(states, inputs, params, iv) => dstates\nfor type=:static:\nf_ip in-place function f(states, inputs, params, iv)\nf_oop out-of-place function f(inputs, params, iv) => states\nalways:\nmassm mass matrix of the system (nothing if :static)\nstates symbols of states (in order)\ninputs symbols of inputs (in order)\nparams symbols of parameters (in order)\nrem_states symbols of removed states (in order)\ng_ip, g_oop functions g((opt. out), states, inputs, params, iv) to calculate the removed states (substituted expl. algebraic equations). nothing if empty.\n\n\n\n\n\n","category":"function"},{"location":"#Block-specifications","page":"Home","title":"Block specifications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sometimes it is useful to define a the input/output structure for a block.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BlockSpec\nfulfills","category":"page"},{"location":"#BlockSystems.BlockSpec","page":"Home","title":"BlockSystems.BlockSpec","text":"struct BlockSpec\n\nBlock specification, defines which inputs/outputs an AbstractIOSystem should have. Contains two vectors of Symbols. Can be initialized with Vectors of Symbols, Num or <:Symbolic.\n\nObject is functor: call (::BlockSpec)(ios) to check wether ios fulfills specification. See also fulfills.\n\niob = IOBlock(...)\nspec = BlockSpec([:uᵣ, :uᵢ], [:iᵣ, :iᵢ])\nfulfills(iob, spec)\nspec(iob)\n\n\n\n\n\n","category":"type"},{"location":"#BlockSystems.fulfills","page":"Home","title":"BlockSystems.fulfills","text":"fulfills(io, bs::BlockSpec)::Bool\n\nCheck whether io fulfills the given BlockSpec.\n\n\n\n\n\n","category":"function"}]
}
